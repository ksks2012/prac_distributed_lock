// Code generated by go-literal-code-gen. DO NOT EDIT.

package mysql

import (
	"context"
	"database/sql"
	"fmt"

	metastore "github.com/semeqetjsakatayza/go-metastore-mysql"
)

const sqlCreateExclusiveLocks = "CREATE TABLE `lock_exclusive_lock` (" +
	"`id` int(4) NOT NULL AUTO_INCREMENT COMMENT 'Primary key'," +
	"`resource_name` varchar(64) NOT NULL DEFAULT '' COMMENT 'Locked resource name'," +
	"`owner` varchar(64) NOT NULL DEFAULT '' COMMENT 'lock owner'," +
	"`desc` varchar(1024) NOT NULL DEFAULT 'Remarks'," +
	"`modified_on` int(10) unsigned DEFAULT '0' COMMENT 'Save data time, automatically generated'," +
	"PRIMARY KEY (`id`)," +
	"UNIQUE KEY `uidx_resource_name` (`resource_name`) USING BTREE" +
	") ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Resource in exclusive lock'"

// ** SQL schema external filter

const metaKeyDistributedLockMetaSchemaRev = "distributed-lock-meta.schema"
const metaKeyExclusiveLocksSchemaRev = "exclusive-locks.schema"

const currentDistributedLockMetaSchemaRev = 1
const currentExclusiveLocksSchemaRev = 1

type schemaRevision struct {
	// TODO: unknown translation mode 0 for symbol [DistributedLockMeta]
	ExclusiveLocks int32
}

func (rev *schemaRevision) IsUpToDate() bool {
	if currentExclusiveLocksSchemaRev != rev.ExclusiveLocks {
		return false
	}
	return true
}

type schemaManager struct {
	referenceTableName string
	ctx                context.Context
	conn               *sql.DB
}

func (m *schemaManager) FetchSchemaRevision() (schemaRev *schemaRevision, err error) {
	metaStoreInst := metastore.MetaStore{
		TableName: metaStoreTableName,
		Ctx:       m.ctx,
		Conn:      m.conn,
	}
	schemaRev = &schemaRevision{}
	if schemaRev.ExclusiveLocks, _, err = metaStoreInst.FetchRevision(metaKeyExclusiveLocksSchemaRev); nil != err {
		return nil, err
	}
	return schemaRev, nil
}

func (m *schemaManager) updateBaseTableSchemaRevision(key string, rev int32) (err error) {
	metaStoreInst := metastore.MetaStore{
		TableName: metaStoreTableName,
		Ctx:       m.ctx,
		Conn:      m.conn,
	}
	err = metaStoreInst.StoreRevision(key, rev)
	return
}

func (m *schemaManager) execBaseSchemaModification(sqlStmt, schemaMetaKey string, targetRev int32) (err error) {
	if _, err = m.conn.Exec(sqlStmt); nil != err {
		return
	}
	return m.updateBaseTableSchemaRevision(schemaMetaKey, targetRev)
}

// upgrade routine for symbol not generated: DistributedLockMeta
func (m *schemaManager) UpgradeSchemaExclusiveLocks(currentRev int32) (schemaChanged bool, err error) {
	switch currentRev {
	case currentExclusiveLocksSchemaRev:
		return false, nil
	case 0:
		if err = m.execBaseSchemaModification(sqlCreateExclusiveLocks, metaKeyExclusiveLocksSchemaRev, currentExclusiveLocksSchemaRev); nil == err {
			return true, nil
		}
	default:
		err = fmt.Errorf("unknown exclusive-locks schema revision: %d", currentRev)
	}
	return
}

// ** Generated code for 2 table entries
